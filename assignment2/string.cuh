/**
 * @file on_device/c_standard_library/string.cuh
 * @brief CUDA device-side versions of the C standard library string operations.
 *
 * @note The implementations are not intended to be particularly speedy - merely functional.
 * In particular - you are advised to only use this when each thread is working on its own
 * string.
 *
 * @note unimplemented functions: strcoll, strxfrm (these require a locale); strerror (errno
 * errors are not generated by device-side code); strtok (not reentrant)
 *
 * @note The implementations are not actually C functions; I've put them in C++ namespaces.
 * This choice could be changed if users demand it.
 */
#ifndef CUDAT_KAT_ON_DEVICE_C_STANDARD_LIBRARY_EQUIVALENTS_STRING_H_
#define CUDAT_KAT_ON_DEVICE_C_STANDARD_LIBRARY_EQUIVALENTS_STRING_H_

#include "sha1.cuh"

using size_t = std::size_t;

/**
 * @brief Lexicographically compares two nul-terminated strings.
 *
 * @note comparison is not locale-specific
 *
 * @return a negative value if lhs > rhs, zero if lhs == rhs and a positive
 * value if lhs < rhs.
 */
inline __device__
int custrcmp(const BYTE* lhs, const BYTE* rhs)
{
    while((*lhs != '\0') and (*rhs == *lhs)) {
		lhs++, rhs++;
    }
    return ((BYTE) *lhs) - ((BYTE) *rhs);
}

/**
 * @brief Lexicographically compares two nul-terminated strings - but no farther than their n'th BYTEacter.
 *
 * @note comparison is not locale-specific.
 *
 * @return a negative value if lhs > rhs, zero if lhs == rhs and a positive
 * value if lhs < rhs - but with the comparisons ignoring everything after the n'th BYTEacter of each
 * of the strings, so - if they differ after then n'th BYTEacter, zero is returned.
 */
inline __device__
int custrncmp(const BYTE* lhs, const BYTE* rhs, size_t n)
{
	while (n && *lhs && (*lhs == *rhs)) {
		++lhs;
		++rhs;
		--n;
	}
	if (n == 0) { return 0; }
	return (*(BYTE *) lhs - *(BYTE *) rhs);
}

/**
 * @brief Lexicographically compare two equal-length sequences of bytes.
 *
 * @note similar to custrncmp, except that the comparison does not stop with 0-valued bytes.
 *
 * @param lhs
 * @param rhs
 * @param n The length of each sequence of bytes
 * @return a negative value if lhs > rhs, zero if lhs == rhs and a positive
 * value if lhs < rhs
 */
inline __device__
int memcmp(const void* lhs, const void* rhs, size_t n)
{
	auto lhs_as_BYTEs = static_cast<const BYTE*>(lhs);
	auto rhs_as_BYTEs = static_cast<const BYTE*>(rhs);
	for(size_t i = 0; i < n; i++) {
		if (lhs_as_BYTEs[i] > rhs_as_BYTEs[i]) { return  1; }
		if (lhs_as_BYTEs[i] < rhs_as_BYTEs[i]) { return -1; }
	}
	return 0;
}

/**
 * @brief Copy a nul-terminated string from one location to another
 *
 * @return the target location (which, after execution, should contain
 * a copy of the string --- when accessed from the calling thread or
 * after appropriate synchronization).
 */
inline __device__
BYTE* custrcpy(BYTE *dst, const BYTE *src)
{
	auto ret = dst;
	while (*src != '\0') { *(dst++) = *(src++); }
	*dst = *src;
	return ret;
}

/**
 * @brief Copy a nul-terminated string from one location to another - but
 * always write no more and no less than a fixed number of BYTEacters.
 *
 * @param dst copy destination
 * @param src string to copy from
 * @param n the number of BYTEacters to write at the destination
 * @return the target location (which, after execution, should contain
 * a copy of the string or the first @p n BYTEacters thereof --- when
 * accessed from the calling thread or after appropriate synchronization).
 */
inline __device__
BYTE* custrncpy(BYTE *dst, const BYTE *src, size_t n)
{
	size_t i = 0;
	auto ret = dst;
	for(; i < n && *src != '\0'; i++, src++, dst++) {
		*dst = *src;
	}
	for(; i < n; i++, dst++) {
		*dst = '\0';
	}
	return ret;
}

/**
 * @brief determines the length of a nul-terminated string
 *
 * @return The length of the string, i.e. the number of BYTEacters
 * before the terminating '\0' (nul) BYTEacter.
 */
inline __device__ __host__
std::size_t custrlen(const BYTE *s)
{
	const BYTE* p = s;
	while(*p != '\0') { p++; }
	return p - s;
}

/**
 * @brief concatenates one string after another, in-place.
 *
 * @param dest The target location for both string (after concatenation)
 * @param src The string to be concatenated.
 * @return A pointer to @p dest, after it has gotten a copy of @p src
 * concatenated at its end.
 */
inline __device__
BYTE *custrcat(BYTE *dest, const BYTE *src)
{
	custrcpy(dest + custrlen(dest), src);
	return dest;
}

/**
 * @brief concatenates one string after another, in-place - but appending
 * no more than a fixed number of BYTEacters to the string at the destination.
 *
 * @param dest The target location for both string (after concatenation)
 * @param src The string to be concatenated.
 * @param n Maximum number of BYTEacters used from the source string
 * @return A pointer to @p dest, after it has gotten a copy of @p src
 * concatenated at its end - or the first @p n BYTEacters of @p src
 * followed with a terminating '\0' (nul).
 */
inline __device__
BYTE *custrncat(BYTE *dest, const BYTE *src, size_t n)
{
	custrncpy(dest + custrlen(dest), src, n);
	return dest;
}

/**
 * @brief copies a stretch of memory from one location to another
 *
 * @note the two regions - @p size bytes at @p source, @p size
 * bytes at @p destination - must be disjoint
 *
 * @param destination beginning of the target region
 * @param source beginning of the source region
 * @param size the length of the memory region to copy
 */
inline __device__
void* memcpy(
	void*        __restrict__  destination,
	const void*  __restrict__  source,
	size_t                     size)
{
	return ::memcpy(destination, source, size);
}

/**
 * @brief set a sequence of bytes in memory to a fixed value
 *
 * @param destination beginning of the sequence of bytes to set
 * @param c value to which to set the bytes; must be in the range
 * of 0 .. (1 << BYTE_BIT) - 1 .
 * @param size number of bytes to set to value @p c.
 */
inline __device__
void* memset(void* destination, int c, size_t size)
{
	::memset(destination, c, size);
	return destination;
}

/**
 * @brief locate a byte with a specified value in a sequence of
 * bytes in memory.
 * @param s beginning of the sequence of bytes at which to begin the search
 * @param c value to search for; must be in the range
 * of 0 .. (1 << BYTE_BIT) - 1 .
 * @param n number of bytes to search for the desired value
 * @return address of the first byte in the sequence with the value @p c,
 * within the sequence starting at @p s, or nullptr if none of the first
 * @p n bytes have that value.
 */
inline __device__
void *cumemchr(const void *s, int c, size_t n)
{
	auto s_end = ((const BYTE *) s) + n;
	for(const BYTE* p = (const BYTE *) s; p < s_end; p++) {
		if (*p == c) { return (void *) p; }
	}
	return nullptr;
}

/**
 * @brief Search for a BYTEacter within a nul-terminated string.
 *
 * @param s The string to search
 * @param c A BYTEacter value to search for
 * @return address of the first BYTEacter with the value @p c
 * within string @p s, or nullptr if no BYTEacter of @p s equals @p c .
 */
inline __device__
BYTE *custrchr(const BYTE *s, int c)
{
	const BYTE* p = s;
	do {
		if (*p == static_cast<BYTE>(c)) {
			return const_cast<BYTE*>(p);
		}
	} while(*(p++) != '\0');
	return nullptr;
}

/**
 * @brief same as @ref std::custrchr , except that the search begins
 * at the end of the string
 *
 * @note If @p c is '\0', it _will_ match the nul BYTEacter
 * at the end of the string.
 *
 */
inline __device__
BYTE *custrrchr(const BYTE *s, int c)
{
	const BYTE* last = nullptr;
	const BYTE* p = s;
	do {
		if (*p == c) { last = p; }
	} while(*(p++) != '\0');
	return const_cast<BYTE*>(last);
}

// Naive implementation!
inline __device__
BYTE *custrpbrk(const BYTE *s, const BYTE *accept)
{
	for(const BYTE* p = s; *p != '\0'; *p++) {
		if (custrchr(accept, *p)) { return const_cast<BYTE*>(p); }
	}
	return nullptr;
}

// Naive implementation!
inline __device__
size_t custrspn(const BYTE *s, const BYTE *accept)
{
	const BYTE* p = s;
	while(*p != '\0' && custrchr(accept, *p)) { p++; }
	return p - s;
}

// Naive implementation!
inline __device__
size_t custrcspn(const BYTE *s, const BYTE *reject)
{
	const BYTE* p = s;
	while(*p != '\0' && !custrchr(reject, *p)) { p++; }
	return p - s;
}

// Naive O(|haystack| * |needle|) implementation!
inline __device__
BYTE *custrstr(const BYTE *haystack, const BYTE *needle)
{
	auto match_prefix = [](const BYTE* s, const BYTE* prefix) {
	    while((*prefix != '\0') and (*s == *prefix)) {
			s++, prefix++;
	    }
	    return (*prefix == '\0');
	};

	do {
		if (match_prefix(haystack, needle)) {
			return const_cast<BYTE *>(haystack);
		}
	} while(*(haystack++) != '\0');
	return (*needle == '\0') ? const_cast<BYTE *>(haystack) : nullptr;
}

// Naive O(|haystack| * |needle|) implementation!
inline __device__
BYTE *strrstr(const BYTE *haystack, const BYTE *needle)
{
	auto match_prefix = [](const BYTE* s, const BYTE* prefix) {
	    while((*prefix != '\0') and (*s == *prefix)) {
			s++, prefix++;
	    }
	    return (*prefix == '\0');
	};

	const BYTE* last_match = nullptr;
	do {
		if (match_prefix(haystack, needle)) {
			last_match = haystack;
		}
	} while(*(haystack++) != '\0');
	return const_cast<BYTE *>((*needle == '\0') ? haystack : last_match);
}

inline __device__ void cudaRevstr(BYTE *str1)  
{  
    // declare variable  
    int i, len, temp;  
    len = custrlen(str1); // use strlen() to get the length of str string  
      
    // use for loop to iterate the string   
    for (i = 0; i < len/2; i++)  
    {  
        // temp variable use to temporary hold the string  
        temp = str1[i];  
        str1[i] = str1[len - i - 1];  
        str1[len - i - 1] = temp;  
    }  
} 

#endif // CUDAT_KAT_ON_DEVICE_C_STANDARD_LIBRARY_EQUIVALENTS_STRING_H_